#pragma once

#include <std_msgs/msg/int32.h>


class MotorController
{
public:
    // Pin information
    int8_t g_Forward;
    int8_t g_Backward;
    // int8_t g_Enable;                    // Enable pin if applicable, NOT implemented
    int8_t g_EncoderPinA;               // pin for the incremental encoder signal
    // int8_t g_EncoderPinB;              // class can be modified to be used with an rotary encoder that provides pulses AND direction
    
    int m_ticksPerRevolution;
    
    std_msgs__msg__Int32 EncoderCount;
    volatile long CurrentPosition;
    volatile long PreviousPosition;
    volatile long CurrentTime;
    volatile long PreviousTime;
    volatile long CurrentTimeforError;
    volatile long PreviousTimeForError;

    // PID variables
    float rpmFilt;
    float eintegral;
    float ederivative;
    float rpmPrev;
    float kp;
    float ki;
    float kd;
    float error;
    float previousError = 0;

    // constructor (for incremmental encoder only)
    MotorController(int8_t ForwardPin, int8_t BackwardPin, int8_t EncoderA, int tickPerRevolution);

    // initializing the parameters of PID controller
    void initPID(float proportionalGain, float integralGain, float derivativeGain);

    // function return rpm of the motor using the encoder tick values
    float getRpm();

    // pid controller
    float pid(float setpoint, float feedback);

    // move the robot wheels based the control signal generated by the pid controller
    void moveBase(float ActuatingSignal, int pwmChannelForward, int pwmChannelBackward);

    void stop();

    // void plot(float Value1, float Value2){
    //     Serial.print("Value1:");
    //     Serial.print(Value1);
    //     Serial.print(",");
    //     Serial.print("value2:");
    //     Serial.println(Value2);
    // }
};